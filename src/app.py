from slack_sdk import WebClient
from slack_bolt.adapter.fastapi import SlackRequestHandler
from slack_bolt import App
from fastapi import FastAPI, Request, BackgroundTasks
from core import run_bot
from config import settings
from utils import get_logger, redis_client

logger = get_logger()


logger.info("Starting Slack bot...")
# Initialize the Slack Bolt app
slack_app = App(
    token=settings.SLACK_BOT_TOKEN, signing_secret=settings.SLACK_SIGNING_SECRET
)

# Initialize FastAPI app
fastapi_app = FastAPI()
handler = SlackRequestHandler(slack_app)


@fastapi_app.get("/health")
async def health_check():
    return {"status": "healthy"}


# def get_bot_user_id():
#     """Fetch the bot user ID using Slack API."""
#     try:
#         slack_client = WebClient(token=settings.SLACK_BOT_TOKEN)
#         response = slack_client.auth_test()
#         return response["user_id"]
#     except SlackApiError as e:
#         logger.info(f"Error fetching bot user ID: {e}")

# Track processed events to avoid duplicates (use Redis in production)


async def process_mention(event_data: dict) -> None:
    """
    Process events with production-grade Redis deduplication.

    This function checks if an event has already been processed by using Redis
    to lock the event ID. If the event is a duplicate, it skips processing.
    If the event is unique, it processes the event, cleans up the text,
    and sends a response via Slack.

    Args:
        event_data (dict): The event data received from Slack, containing event details such as the event ID, text, and channel.

    Returns:
        None: This function does not return any value, it only performs side effects (logging, sending messages).
    """
    logger.info(f"⏩ Starting to process event ID: {event_data.get('event_id')}")

    event_id = event_data.get("event_id")  # Extract event ID
    redis_key = f"slack:event:{event_id}"  # Redis key for deduplication

    try:
        # Attempt to acquire a lock in Redis to prevent duplicate processing
        lock_acquired = redis_client.set(redis_key, "1", nx=True, ex=3600)

        if not lock_acquired:
            # Lock not acquired means the event has already been processed
            logger.info(f"⏭️ Duplicate detected! Skipping event: {event_id}")
            logger.info(f"Skipping duplicate event: {event_id}")
            return

        logger.info(f"Processing event: {event_data}")
        text = event_data["event"]["text"]  # Get the text from the event data
        mention = f"<@{settings.SLACK_BOT_USER_ID}>"  # Format the bot mention
        cleaned_text = text.replace(
            mention, ""
        ).strip()  # Remove the mention from the text

        logger.info(f"Processing mention: {cleaned_text}")
        response = run_bot(cleaned_text)  # Process the cleaned text with the bot

        # Use WebClient to send the response via Slack
        slack_client = WebClient(token=settings.SLACK_BOT_TOKEN)
        slack_client.chat_postMessage(
            channel=event_data["event"]["channel"],  # The Slack channel
            text=response,  # The response generated by the bot
        )
    except Exception as e:
        # Log any errors that occur during processing
        logger.error(f"Error processing slack bot mention: {e}")


@slack_app.event("app_mention")
def handle_mentions(body: dict, say):
    logger.info(f"Received mention (acknowledged): {body['event']['text']}")
    # Just acknowledge - processing happens in process_mention()


@fastapi_app.post("/slack/events")
async def endpoint(req: Request, background_tasks: BackgroundTasks):
    """
    FastAPI endpoint that:
    1. Immediately responds to Slack with 200 OK.
    2. Processes events in the background.
    """
    try:
        # Parse the request body (but don't fully process yet)
        body = await req.json()

        # Let Slack Bolt verify the request (signing secret, etc.)
        response = await handler.handle(req)

        # If it's an event (like app_mention), process it in the background
        if body.get("type") == "event_callback":
            background_tasks.add_task(process_mention, body)

        return response
    except Exception as e:
        logger.error(f"Slack event handler error: {e}")
        raise
